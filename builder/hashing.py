"""
ShadowGate - API Hashing Module
Implements multiple hash algorithms for string hiding
"""

import struct
from typing import Dict, List, Tuple

# ============================================================================
# Hash Algorithms
# ============================================================================

class HashEngine:
    """API name hashing engine"""
    
    # DJB2 seed (from HookChain)
    DJB2_SEED = 0x7734773477347734
    
    @staticmethod
    def djb2(data: bytes, seed: int = None) -> int:
        """
        DJB2 hash algorithm (64-bit)
        Used by HookChain for API resolution
        """
        if seed is None:
            seed = HashEngine.DJB2_SEED
        
        hash_value = seed
        
        for byte in data:
            hash_value = ((hash_value << 5) + hash_value) + byte
            hash_value &= 0xFFFFFFFFFFFFFFFF  # Keep 64-bit
        
        return hash_value
    
    @staticmethod
    def djb2_32(data: bytes) -> int:
        """DJB2 hash algorithm (32-bit version)"""
        hash_value = 5381
        
        for byte in data:
            hash_value = ((hash_value << 5) + hash_value) + byte
            hash_value &= 0xFFFFFFFF  # Keep 32-bit
        
        return hash_value
    
    @staticmethod
    def crc32(data: bytes) -> int:
        """CRC32 hash"""
        import zlib
        return zlib.crc32(data) & 0xFFFFFFFF
    
    @staticmethod
    def fnv1a_64(data: bytes) -> int:
        """FNV-1a hash algorithm (64-bit)"""
        FNV_OFFSET = 0xcbf29ce484222325
        FNV_PRIME = 0x100000001b3
        
        hash_value = FNV_OFFSET
        
        for byte in data:
            hash_value ^= byte
            hash_value = (hash_value * FNV_PRIME) & 0xFFFFFFFFFFFFFFFF
        
        return hash_value
    
    @staticmethod
    def xor_hash(data: bytes, key: int = 0x5A) -> int:
        """Simple XOR-based hash (32-bit)"""
        hash_value = 0
        
        for i, byte in enumerate(data):
            hash_value ^= (byte ^ key) << ((i % 4) * 8)
            hash_value = ((hash_value << 7) | (hash_value >> 25)) & 0xFFFFFFFF
        
        return hash_value
    
    @classmethod
    def hash_api_name(cls, name: str, algorithm: str = "djb2", skip_prefix: int = 0) -> int:
        """
        Hash an API name
        
        Args:
            name: API function name (e.g., "NtAllocateVirtualMemory")
            algorithm: Hash algorithm to use
            skip_prefix: Number of characters to skip (e.g., 2 for "Nt"/"Zw")
        """
        # Convert to bytes and optionally skip prefix
        data = name[skip_prefix:].encode('ascii')
        
        if algorithm == "djb2":
            return cls.djb2(data)
        elif algorithm == "djb2_32":
            return cls.djb2_32(data)
        elif algorithm == "crc32":
            return cls.crc32(data)
        elif algorithm == "fnv1a":
            return cls.fnv1a_64(data)
        elif algorithm == "xor":
            return cls.xor_hash(data)
        else:
            raise ValueError(f"Unknown algorithm: {algorithm}")
    
    @classmethod
    def generate_hash_table(cls, api_names: List[str], algorithm: str = "djb2", 
                           skip_prefix: int = 2) -> Dict[str, int]:
        """Generate hash table for list of API names"""
        table = {}
        for name in api_names:
            hash_value = cls.hash_api_name(name, algorithm, skip_prefix)
            table[name] = hash_value
        return table
    
    @classmethod
    def generate_cpp_defines(cls, api_names: List[str], algorithm: str = "djb2",
                            skip_prefix: int = 2) -> str:
        """Generate C++ #define statements for API hashes"""
        lines = []
        lines.append(f"// API Hashes (Algorithm: {algorithm.upper()})")
        lines.append(f"// Auto-generated by ShadowGate Builder\n")
        
        for name in api_names:
            hash_value = cls.hash_api_name(name, algorithm, skip_prefix)
            # Create define name: NtAllocateVirtualMemory -> HASH_NtAllocateVirtualMemory
            define_name = f"HASH_{name}"
            lines.append(f"#define {define_name:<45} 0x{hash_value:016X}ULL")
        
        return '\n'.join(lines)
    
    @classmethod
    def generate_cpp_hash_function(cls, algorithm: str = "djb2") -> str:
        """Generate C++ hash function code"""
        
        if algorithm == "djb2":
            return '''
// DJB2 Hash Function (64-bit)
__forceinline DWORD64 HashString(LPCSTR str) {
    DWORD64 hash = 0x7734773477347734ULL;
    while (*str) {
        hash = ((hash << 5) + hash) + (DWORD64)*str++;
    }
    return hash;
}

// Hash with prefix skip (for Nt/Zw functions)
__forceinline DWORD64 HashApi(LPCSTR name, DWORD skip) {
    return HashString(name + skip);
}
'''
        elif algorithm == "fnv1a":
            return '''
// FNV-1a Hash Function (64-bit)
__forceinline DWORD64 HashString(LPCSTR str) {
    DWORD64 hash = 0xcbf29ce484222325ULL;
    const DWORD64 prime = 0x100000001b3ULL;
    while (*str) {
        hash ^= (DWORD64)*str++;
        hash *= prime;
    }
    return hash;
}

// Hash with prefix skip
__forceinline DWORD64 HashApi(LPCSTR name, DWORD skip) {
    return HashString(name + skip);
}
'''
        elif algorithm == "crc32":
            return '''
// CRC32 Hash Function
static const DWORD crc32_table[256] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, /* ... full table ... */
};

__forceinline DWORD HashString(LPCSTR str) {
    DWORD crc = 0xFFFFFFFF;
    while (*str) {
        crc = crc32_table[(crc ^ *str++) & 0xFF] ^ (crc >> 8);
    }
    return crc ^ 0xFFFFFFFF;
}
'''
        else:
            return f"// Hash algorithm '{algorithm}' not implemented in C++"
    
    @classmethod
    def get_common_api_hashes(cls, algorithm: str = "djb2") -> Dict[str, int]:
        """Get hashes for commonly used NT APIs"""
        common_apis = [
            "NtAllocateVirtualMemory",
            "NtProtectVirtualMemory",
            "NtWriteVirtualMemory",
            "NtReadVirtualMemory",
            "NtCreateThreadEx",
            "NtOpenProcess",
            "NtClose",
            "NtQueryInformationProcess",
            "NtQueryVirtualMemory",
            "NtFreeVirtualMemory",
            "NtResumeThread",
            "NtSuspendThread",
            "NtQueueApcThread",
            "NtWaitForSingleObject",
            "NtDelayExecution",
            "NtCreateSection",
            "NtMapViewOfSection",
            "NtUnmapViewOfSection",
            "NtCreateProcess",
            "NtCreateProcessEx",
            "NtTerminateProcess",
        ]
        return cls.generate_hash_table(common_apis, algorithm, skip_prefix=2)


# ============================================================================
# String Obfuscation
# ============================================================================

class StringObfuscator:
    """String obfuscation utilities"""
    
    @staticmethod
    def xor_string(s: str, key: int = 0x5A) -> bytes:
        """XOR obfuscate a string"""
        return bytes([ord(c) ^ key for c in s])
    
    @staticmethod
    def generate_xor_string_cpp(s: str, var_name: str, key: int = 0x5A) -> str:
        """Generate C++ code for XOR-obfuscated string"""
        obfuscated = StringObfuscator.xor_string(s, key)
        
        hex_bytes = ', '.join(f'0x{b:02X}' for b in obfuscated)
        
        code = f'''
// Obfuscated string: "{s}"
unsigned char {var_name}_enc[] = {{ {hex_bytes}, 0x00 }};
#define {var_name}_KEY 0x{key:02X}
#define {var_name}_LEN {len(s)}

__forceinline void Deobfuscate_{var_name}(char* out) {{
    for (int i = 0; i < {var_name}_LEN; i++) {{
        out[i] = {var_name}_enc[i] ^ {var_name}_KEY;
    }}
    out[{var_name}_LEN] = 0;
}}
'''
        return code
    
    @staticmethod
    def generate_stack_string_cpp(s: str, var_name: str) -> str:
        """Generate C++ code for stack-built string"""
        lines = [f"    // Stack string: \"{s}\""]
        lines.append(f"    char {var_name}[{len(s) + 1}];")
        
        for i, c in enumerate(s):
            lines.append(f"    {var_name}[{i}] = '{c}';")
        
        lines.append(f"    {var_name}[{len(s)}] = '\\0';")
        
        return '\n'.join(lines)
    
    @staticmethod
    def reverse_with_junk(s: str) -> bytes:
        """
        Reverse string and add junk characters (HookChain style)
        """
        result = bytearray()
        junk_chars = b'@#$%^&*()!-+=[]{}|;:,.<>?'
        
        for i, c in enumerate(reversed(s)):
            result.append(ord(c))
            # Add junk after some characters
            if i % 2 == 0 and i < len(s) - 1:
                result.append(junk_chars[i % len(junk_chars)])
        
        result.append(0)  # Null terminator
        return bytes(result)
    
    @staticmethod
    def generate_reversed_junk_cpp(s: str, var_name: str) -> str:
        """Generate C++ code for reversed+junk obfuscated string"""
        obfuscated = StringObfuscator.reverse_with_junk(s)
        hex_bytes = ', '.join(f'0x{b:02X}' for b in obfuscated)
        
        code = f'''
// Obfuscated (reversed+junk): "{s}"
unsigned char {var_name}_enc[] = {{ {hex_bytes} }};

__forceinline void Decode_{var_name}(char* out) {{
    int j = 0;
    int len = sizeof({var_name}_enc) - 1;
    for (int i = len - 1; i >= 0; i--) {{
        char c = {var_name}_enc[i];
        // Filter: only alphanumeric and underscore
        if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || 
            (c >= 'a' && c <= 'z') || c == '_' || c == '.') {{
            out[j++] = c;
        }}
    }}
    out[j] = '\\0';
}}
'''
        return code


# ============================================================================
# Test
# ============================================================================

if __name__ == "__main__":
    engine = HashEngine()
    
    # Test hash algorithms
    test_name = "AllocateVirtualMemory"  # Without Nt prefix
    
    print("Hash Algorithm Comparison:")
    print(f"  Input: '{test_name}'")
    print(f"  DJB2:    0x{engine.djb2(test_name.encode()):016X}")
    print(f"  DJB2_32: 0x{engine.djb2_32(test_name.encode()):08X}")
    print(f"  CRC32:   0x{engine.crc32(test_name.encode()):08X}")
    print(f"  FNV-1a:  0x{engine.fnv1a_64(test_name.encode()):016X}")
    print(f"  XOR:     0x{engine.xor_hash(test_name.encode()):08X}")
    
    # Generate defines
    print("\n" + "="*60)
    print(engine.generate_cpp_defines([
        "NtAllocateVirtualMemory",
        "NtProtectVirtualMemory",
        "NtWriteVirtualMemory",
    ]))
    
    # Test string obfuscation
    print("\n" + "="*60)
    obf = StringObfuscator()
    print(obf.generate_xor_string_cpp("kernel32.dll", "g_Kernel32"))
    print(obf.generate_stack_string_cpp("ntdll.dll", "szNtdll"))